% Created 2022-02-02 mié 21:03
% Intended LaTeX compiler: pdflatex
\documentclass[xcolor={usenames,svgnames,dvipsnames}, aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{color}
\usepackage{listings}
\usepackage[spanish]{babel}
\usecolortheme{rose}
\setbeamercolor{alerted text}{fg=DarkBlue}
\setbeamerfont{alerted text}{series=\bfseries}
\setbeamerfont{block title}{series=\bfseries}
\setbeamercolor{block title}{bg=structure.fg!20!bg!50!bg}
\setbeamercolor{block body}{use=block title,bg=block title.bg}
\setbeamertemplate{navigation symbols}{\insertsectionnavigationsymbol}
\AtBeginSection[]{\begin{frame}[plain]\tableofcontents[currentsection,sectionstyle=show/shaded]\end{frame}}
\AtBeginSubsection[]{\begin{frame}[plain]\tableofcontents[currentsubsection,sectionstyle=show/shaded,subsectionstyle=show/shaded]\end{frame}}
\lstset{keywordstyle=\color{blue}, commentstyle=\color{gray!90}, basicstyle=\ttfamily\small, columns=fullflexible, breaklines=true,linewidth=\textwidth, backgroundcolor=\color{gray!23}, basewidth={0.5em,0.4em}, literate={¡}{{\textexclamdown}}1 {á}{{\'a}}1 {ñ}{{\~n}}1 {é}{{\'e}}1 {ó}{{\'o}}1 {í}{{\'i}}1 {ú}{{\'u}}1 {º}{{\textordmasculine}}1, showstringspaces=false}
\usepackage{mathpazo}
\usepackage{siunitx}
\hypersetup{colorlinks=true, linkcolor=Blue, urlcolor=Blue}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{verbatim}{Verbatim}{fontsize=\tiny, formatcom = {\color{black!70}}}
\setbeamertemplate{footline}[frame number]
\usetheme{Boadilla}
\usefonttheme{serif}
\author{Oscar Perpiñán Lamigueiro}
\date{}
\title{Tema 4: Tipos Avanzados de Datos}
\hypersetup{
 pdfauthor={Oscar Perpiñán Lamigueiro},
 pdftitle={Tema 4: Tipos Avanzados de Datos},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.4.6)}, 
 pdflang={Spanish}}
\begin{document}

\maketitle

\section{Vectores}
\label{sec:orge80b3ff}
\begin{frame}[label={sec:orgf62b5ee},fragile]{Vectores en C}
 \begin{block}{Definición}
Conjunto de valores numéricos del mismo tipo
\end{block}

\begin{block}{Código}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
 tipo identificador[dimensión];
\end{lstlisting}

\begin{description}
\item[{tipo}] Tipo de los elementos del vector (\texttt{int}, \texttt{float}, etc.).
\item[{identificador}] Nombre del vector.
\item[{dimensión}] Número de elementos del vector (literal entero).
\end{description}
\end{block}
\end{frame}

\begin{frame}[label={sec:orgc454275},fragile]{Ejemplos}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Declara un vector llamado miVector compuesto  por 
// tres elementos de tipo int.  
int miVector[3];

// Declara un vector e inicializa todos sus elementos
int miVector[3] = {2, 23, 0};

// Declara un vector e inicializa el primer elemento
// (resto quedan a 0)
int miVector[3] = {2};

// Declara un vector sin dimensión. 
// La dimensión queda determinada a partir 
// del numero de elementos
int miVector[] = {2, 23, 24};

\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgd53d42d},fragile]{Elementos de un vector}
 \begin{itemize}
\item Se referencian con el nombre del vector seguido de un subíndice entre corchetes.
\item El subíndice representa la posición del elemento dentro del vector.
\item La \alert{primera posición} del vector tiene el \alert{subíndice 0}.
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main(){
  int miVector[3];
  miVector[0] = 10;
  miVector[1] = 2 * miVector[0];
  miVector[2] = miVector[0] + miVector[1];

  printf("Posicion 0 = %d\n", miVector[0]);
  printf("Posicion 1 = %d\n", miVector[1]);
  printf("Posicion 2 = %d\n", miVector[2]);

  return 0;
}

\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgac7e88a},fragile]{Acceso a datos de un vector}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  float temp[3];

  printf("Indique tres valores reales.\n");
  scanf("%f %f %f",
	&temp[0], &temp[1], &temp[2]);

  printf("La media de estos valores es: %f\n",
	 (temp[0] + temp[1] + temp[2])/3);

  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orge4e8274},fragile]{Acceso a datos de un vector}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  float temp[5] = {2.1, 4.9, 0.51, 4.3, 9.01};
  int i;
  // Es común el uso de bucles for para
  // recorrer un vector. Es importante
  // recordar que el primer elemento 
  // tiene índice 0.
  for (i = 0; i < 5; i++)
    printf("El elemento %d es %f\n",
	   i + 1, temp[i]);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orge1da0c1},fragile]{Operaciones con vectores}
 \begin{block}{Suma de dos vectores}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main(){
  float v1[5] = {1, 34, 32, 45, 34};
  float v2[5] = {12, -3, 34, 15, -5};
  float v3[5];
  int i;
  
  for(i = 0; i < 5; i++)
      v3[i] = v1[i] + v2[i];

  printf("Vector3: ");
  for(i = 0; i < 5; i++)
    printf("%f ", v3[i]);
  printf("\n");
  return 0;
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[label={sec:org8d98d05},fragile]{Operaciones con vectores}
 \begin{block}{Multiplicar un vector por una constante}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h> 
int main(){
  float v1[5] = {1, 34, 32, 45, 34};
  float v2[5];
  float K = 3.0;
  int i;
  
  for(i = 0; i < 5; i++)
      v2[i] = K * v1[i];

  for(i = 0; i < 5; i++)
    printf("V1: %f\t V2: %f\n",
	   v1[i], v2[i]);

  return 0;
}
\end{lstlisting}
\end{block}
\end{frame}


\begin{frame}[label={sec:orgdf7fcf1},fragile]{Vectores de dimensión variable}
 La dimensión de un vector es un valor constante: \alert{no puede usarse una variable} para definirla.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
int main()
{
  int miVector[10];

  return 0;
}
\end{lstlisting}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
# define N 10
int main()
{
  // Correcto: el precompilador sustituye N
  // por el valor constante 10
  int miVector[N];

  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgeaf3fac},fragile]{Vectores de dimensión variable}
 La dimensión de un vector es un valor constante: \alert{no puede usarse una variable} para definirla.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
int main()
{
  int n = 10;
  // Error de sintaxis:
  // n es una variable
  int miVector[n];

  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org4d1ccb0},fragile]{Vectores de Dimensión Variable}
 \alert{Solución provisional}: definir un vector de dimensión suficientemente elevada y emplear sólo un número reducido de elementos.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main() {
  int i, n;
  // Definimos un vector de dimension muy grande
  int vect[100];

  printf("Nº datos? ");
  //El usuario debe teclear un n < 100
  scanf("%d", &n); 
  //Utilizamos solo las n primeras
  for(i = 0; i < n; i++) 
    {
      scanf("%d", &vect[i]);
    }
  return 0;
}
\end{lstlisting}
\end{frame}
\begin{frame}[label={sec:orgb77c948},fragile]{Funciones con vectores}
 \begin{block}{Paso por referencia}
Cuando un vector se pasa como argumento a una función \alert{no se pasa el vector completo} sino la \alert{dirección de memoria del primer elemento}.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void funcion (int vector[], int dimension);
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[label={sec:org863a762},fragile]{Funciones con vectores}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

void imprime(int v[], int n);

int main()
{
  int v1[3] = {10, 20, 30};
  imprime(v1, 3);
  return 0;
} 

void imprime(int v[], int n)
{
  int i;
  for(i = 0; i < n; i++)
    printf("%d\n",v[i]);
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgf672380},fragile,plain]{Funciones con vectores: paso por referencia}
 La función \alert{puede modificar} el contenido de los elementos del vector ya que conoce la dirección de memoria donde están almacenados.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

void toy(int vector[]);

int main()
{
  int x[] = {1, 2, 3};
  printf("Antes: %d\n", x[0]);
  toy(x); // ¡Sin asignacion!
  printf("Después: %d\n", x[0]);
  return 0;
}

void toy(int vector[]){ 
  //Funcion simple que modifica el valor del primer elemento
  vector[0] = 100;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgb2081d7},fragile,plain]{Otro ejemplo de funciones con vectores}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

void fAbs(int vector[], int n);

int main(){
  int datos[5]={-1, 3, -5, 7, -9}, i;
  fAbs(datos, 5); //¡Sin asignacion!

  for(i = 0; i < 5; i++)   // Mostramos el resultado
    printf("%d ",datos[i]);
  return 0;
}
// La funcion recibe la direccion del primer elemento
void fAbs(int vector[], int n){
  int i;
  for(i = 0; i < n; i++)
      if(vector[i] < 0)
	vector[i] = -vector[i];
}
\end{lstlisting}
\end{frame}

\section{Cadenas de caracteres}
\label{sec:orgc4bf7db}
\begin{frame}[label={sec:orgb3c6cda},fragile]{Cadenas de caracteres en C}
 \begin{block}{Definición}
Conjunto de caracteres individuales (\texttt{char})
\end{block}
\begin{block}{Código}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
 char identificador[dimensión];
\end{lstlisting}

\begin{description}
\item[{tipo}] \texttt{char}
\item[{identificador}] Nombre de la cadena.
\item[{dimensión}] Número de elementos de la cadena (constante entero) \alert{incluyendo el carácter de cierre} (\texttt{\textbackslash{}0}).
\end{description}
\end{block}
\end{frame}

\begin{frame}[label={sec:org9afdddb},fragile]{Definición e Inicialización de cadenas}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Declara una cadena de 10 caracteres 
//(+1 para el cierre)
char cadena[11];

// Declara y asigna contenido
char cadena[5] = "Hola"; // 4 + 1

// Asigna por valores individuales
char cadena[5] = {'H', 'o', 'l', 'a', '\0'}; // 4 + 1

// Asigna por codigo ASCII
char cadena[5] = {72, 111, 108, 97, 0}; 

\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org13e09d4},fragile]{Definición e Inicialización de cadenas}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Declara una cadena, *no* define dimension 
// y asigna contenido 
char cadena[] = "Hola"; 

// Asigna por elementos individuales
char cadena[] = {'H', 'o', 'l', 'a', '\0'}; // 4 + 1; 

// Asigna mediante codigo ASCII
char cadena[] = {72, 111, 108, 97, 0}; 
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org0883157},fragile]{Elementos de una cadena}
 \begin{itemize}
\item Se referencian con el nombre seguido de un subíndice entre corchetes.
\item El subíndice representa la posición del elemento dentro de la cadena.
\item La \alert{primera posición} tiene el \alert{subíndice 0}.
\item La \alert{última posición} es el carácter nulo \texttt{\textbackslash{}0}.
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  char cadena[5] = "Hola";
  printf("%c \t %c \t %c \t %c \t %c\n",
	 cadena[0], cadena[1],
	 cadena[2], cadena[3],
	 cadena[4]);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgf9414a2},fragile]{Asignación de valores}
 \begin{block}{Error}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
char cadena[5];

//Error de compilacion
cadena = "Hola";
\end{lstlisting}
\end{block}

\begin{block}{Solución provisional}
\emph{Mejor con \texttt{strcpy} de \texttt{string.h}}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
char cadena[5]; 
cadena[0] = 'H'; 
cadena[1] = 'o'; 
cadena[2] = 'l'; 
cadena[3] = 'a'; 
cadena[4] = '\0';
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[label={sec:org5962f73},fragile]{Lectura y escritura de una cadena}
 \begin{itemize}
\item Usamos el especificador \texttt{\%s} con \texttt{printf} y \texttt{scanf}.

\item En \texttt{scanf} \alert{debemos} especificar el \alert{límite de caracteres} en el especificador de formato.

\item En \texttt{scanf} \alert{no} ponemos \texttt{\&} delante del identificador.
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  char texto[31];

  printf("Dime algo: \n");
  // Deja de leer cuando detecta un espacio
  // Imponemos el límite de caracteres
  scanf("%30s", texto); 
  printf("Has dicho %s", texto);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org616c3c4},fragile]{Lectura de una cadena con espacios}
 \begin{itemize}
\item \texttt{scanf} con \texttt{\%s} termina de leer cuando recibe un espacio o salto de línea.
\item Para leer cadenas de caracteres que incluyan espacios se emplea el identificador \texttt{\%[\textasciicircum{}\textbackslash{}n]}
\end{itemize}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  char texto[31];

  printf("Dime algo: \n");
  // Deja de leer cuando detecta un salto de línea
  // o al alcanzar el límite de caracteres
  scanf("%30[^\n]", texto);
  // En printf seguimos usando %s
  printf("Has dicho %s\n", texto);
  return 0;
}
\end{lstlisting}
\end{frame}
\begin{frame}[label={sec:org2c54c68},fragile]{Recorrido por los elementos}
 \begin{itemize}
\item El bucle \texttt{while} es el más indicado, usando el carácter nulo para terminar:
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  char cadena[5] = "Hola";
  int i = 0;
  printf("Los caracteres son:\n");
  while (cadena[i] != '\0')
    {
      printf("%c \t", cadena[i]);
      i++;
    }
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgcc22982},fragile]{Recorrido por los elementos}
 \begin{itemize}
\item También se puede usar un bucle \texttt{for} (equivalencia entre \texttt{for} y \texttt{while})
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main()
{
  char cadena[5] = "Hola";
  int i;
  printf("Los caracteres son:\n");
  for(i = 0; cadena[i] != '\0'; i++)
    {
      printf("%c \t", cadena[i]);
    }
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:orgd9f8e2e},fragile,plain]{Ejemplo: pasar a mayúsculas}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

int main() {
  char cadena[5] = "Hola";
  // Distancia entre A y a
  int inc = 'A' - 'a';
  int i = 0;
  // Recorremos la cadena
  while(cadena[i] != '\0')
    { // Si el caracter es letra minuscula
      if (cadena[i] >= 'a' && cadena[i] <= 'z')
	//sumamos la distancia para pasar a mayuscula
	cadena[i] += inc;
      i++;
    }
  printf("%s\n", cadena);

  return 0;
}
\end{lstlisting}
\end{frame}
\begin{frame}[label={sec:org96b33f6},fragile]{Librería \texttt{string.h}}
 \begin{block}{}
La librería \texttt{string.h} incluye numerosas funciones dedicadas a cadenas de caracteres:

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <string.h>
\end{lstlisting}

\begin{description}
\item[{Longitud de una cadena}] \texttt{strlen}
\item[{Paso a mayúsculas}] \texttt{\_strup}
\item[{Copiar cadenas}] \texttt{strcpy}
\item[{Concatenar cadenas}] \texttt{strcat}
\item[{Comparación de cadenas}] \texttt{strcmp}
\end{description}
\end{block}
\end{frame}

\begin{frame}[label={sec:org292eb38},fragile]{Longitud de una cadena :: \texttt{strlen}}
 \begin{itemize}
\item \texttt{strlen} devuelve un entero con el número de caracteres.
\end{itemize}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

int main()
{
  char palabra[21];
  int longitud;
  printf("Introduce una palabra: ");
  scanf("%20s", palabra);
  longitud = strlen(palabra);
  printf("Esta palabra tiene %d caracteres\n",
	 longitud);
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:org8b56290},fragile]{Copiar cadenas :: \texttt{strcpy}}
 Con \texttt{strcpy} tenemos una solución óptima para la \alert{asignación de contenido}.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
int main()
{
  char s1[50], s2[50];
  strcpy(s1, "Hello World!");
  strcpy(s2, s1);
  printf("%s\n", s2);
  return 0;
}
\end{lstlisting}

\begin{block}{}
La cadena receptora debe tener espacio suficiente: \emph{los caracteres sobrantes serán eliminados}.
\end{block}
\end{frame}

\begin{frame}[label={sec:org2bcb2fd},fragile]{Concatenar cadenas :: \texttt{strcat}}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

int main() {
  char nombre_completo[50];
  char nombre[ ] = "Juana";
  char apellido[ ] = "de Arco";
  // Copiamos por tramos:
  // Primero el nombre
  strcpy(nombre_completo, nombre);
  // A continuacion un espacio
  strcat(nombre_completo, " ");
  // Finalmente el apellido
  strcat(nombre_completo, apellido);
  printf("El nombre completo es: %s.\n",
	 nombre_completo);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgfa61162},fragile]{Comparación de cadenas :: \texttt{strcmp}}
 \begin{itemize}
\item \alert{Si las dos cadenas son iguales entrega un 0}.
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
int main()
{
  char color[] = "negro";
  char respuesta[11];
  do // El bucle se repite mientras
    {// las cadenas *no* coincidan
      printf("Adivina un color: ");
      scanf ("%10s", respuesta);
    } while (strcmp(color, respuesta) != 0);
  printf("¡Correcto!\n");
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgc81d6ae},fragile]{Comparación de cadenas :: \texttt{strcmp}}
 \begin{itemize}
\item Si hay diferencias, es positivo si el valor ASCII del primer carácter diferente es mayor en la cadena 1.
\end{itemize}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
int main()
{
  char s1[] = "abcdef";
  char s2[] = "abCdef";
  char s3[] = "abcdff";
  int res;
  res = strcmp(s1, s2);
  printf("strcmp(s1, s2) = %d\n",
	 res);
  res = strcmp(s1, s3);
  printf("strcmp(s1, s3) = %d\n",
	 res);
return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org475c0f5},fragile]{Funciones y cadenas}
 Una función acepta una cadena como argumento: \alert{paso por referencia} (igual que un vector).

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
void imprime(char cadena[]); 

int main() {
  char saludo[]="Hola";
  imprime(saludo);
  return 0;
}
void imprime(char cadena[]) {
  int i=0;
  while(cadena[i]!='\0') {
      printf("%c", cadena[i]);
      i++;
    }
  printf("\n");
}
\end{lstlisting}
\end{frame}
\section{Matrices}
\label{sec:orgef79331}
\begin{frame}[label={sec:org41dbc34},fragile]{Matrices}
 \begin{block}{}
Una matriz es un conjunto de valores del mismo tipo (\texttt{int}, \texttt{char}, \texttt{float}, etc.), de dos o más dimensiones
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
tipo identificador[dimension_1][dimension_2] ... [dimension_n];
\end{lstlisting}

\begin{description}
\item[{tipo}] Tipo de los elementos de la matriz.
\item[{identificador}] Nombre de la matriz.
\item[{dimensión\textsubscript{n}}] Dimensión n-ésima de la matriz.
\end{description}
\end{block}

\begin{block}{Ejemplo}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
// Crea una matriz de datos enteros, llamada
// tabla, de dos dimensiones y 9 elementos.
int tabla[3][3];
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[label={sec:org33208d5},fragile,plain]{Elementos de una matriz}
 Se referencian con el nombre de la matriz seguido de tantos subíndices, entre corchetes, como dimensiones tenga la matriz.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main (){
  int matriz[2][2]; // Matriz 2 x 2
  int fila, columna;
  // Inicializacion de elementos
  matriz[0][0] = 1;
  matriz[0][1] = 2;
  matriz[1][0] = 3;
  matriz[1][1] = 4;
  // Recorre matriz con un bucle for anidado
  for(fila = 0; fila < 2; fila++) {
      for(columna = 0; columna < 2; columna++)
	printf("%d\t", matriz[fila][columna]);
      printf("\n\n");
    }
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:orgf15bd5d},fragile]{Inicialización de una matriz}
 Los elementos de una matriz pueden iniciarse en el momento de la declaración.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main() {
  int matriz[2][3] = // Matriz 2 x 3
    {
      {10, 20, 30}, // 1a fila
      {40, 50, 60}  // 2a fila
    };
  int fil, col;
  // Recorremos con bucle anidado
  for(fil = 0; fil < 2; fil++){
      for(col = 0; col < 3; col++)
	printf("%d\t",matriz[fil][col]);
      printf("\n\n");
    }
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:orgb1373b7},fragile]{Inicialización de una matriz}
 Los elementos de una matriz pueden iniciarse en el momento de la declaración.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main()
{
  // Matriz de dos filas, tres columnas
  int matriz[2][3] = {10, 20, 30, 40, 50, 60};
  int fil, col;
  // Recorremos con bucle anidado
  for(fil = 0; fil < 2; fil++)
    {
      for(col = 0; col < 3; col++)
	printf("%d\t",matriz[fil][col]);
      printf("\n\n");
    }
return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:org2afc53c},fragile,plain]{Operaciones con matrices: suma}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
int main() {
  int i,j;
  int m1[2][3] = {1, 2, 3, 4, 5, 6};
  int m2[2][3] = {4, 5, 12, 23, -5, 6};
  int m3[2][3]; // Matriz resultado
  // Realiza la suma con bucle anidado
  for(i = 0; i < 2; i++) // Filas
    for(j = 0; j < 3; j++) // Columnas
      m3[i][j] = m1[i][j] + m2[i][j];
  // Imprime resultado con bucle anidado
  for(i = 0; i < 2; i++) // Filas
    {
      for(j = 0; j < 3; j++) // Columnas
	  printf("%d\t",m3[i][j]);
      printf("\n");
    }
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgebf4684},fragile]{Funciones con matrices}
 \begin{itemize}
\item Una matriz siempre se pasa por referencia: no se pasa la matriz completa sino la dirección del primer elemento.
\end{itemize}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void funcion (int matriz[3][3], int nFil, int nCol);
\end{lstlisting}

\begin{itemize}
\item Se puede omitir el número de filas pero \alert{no} el número de columnas.
\end{itemize}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
void funcion (int matriz[][3], int nFil, int nCol);
\end{lstlisting}

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
//Error de sintaxis
void funcion (int matriz[][], int nFil, int nCol);
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org206e885},fragile,plain]{Ejemplo de función con matrices}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
void imprime_matriz(int M[][2], int f, int c);

int main()
{
  int tabla[2][2] = {{1,2}, {3,4}};
  imprime_matriz(tabla, 2, 2);
  return 0;
}

void imprime_matriz(int M[][2], int f, int c)
{
  int i, j;
  for(i = 0; i < f; i++) {
      for(j = 0; j < c; j++)
	printf("%d ", M[i][j]);
      printf("\n");
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgf45c273},fragile,plain]{Ejemplo de función con matrices (2)}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
void absMatriz(int M[][2], int f, int c);

int main() {
  int tabla[2][2] = {{-1,2}, {-3,4}};
  printf("Antes: %d\n", tabla[0][0]);
  absMatriz(tabla, 2, 2); // ¡Sin asignacion!
  printf("Después: %d\n", tabla[0][0]);
  return 0;
}

void absMatriz(int M[][2], int f, int c) {
  int i, j;
  for(i = 0; i < f; i++) 
      for(j = 0; j < c; j++)
	if (M[i][j] < 0)
	  M[i][j] = -M[i][j];
}
\end{lstlisting}
\end{frame}


\section{Estructuras}
\label{sec:org95ab300}
\begin{frame}[label={sec:org873e400},fragile]{Estructuras en C}
 Permiten almacenar valores de diferentes tipos bajo un mismo identificador.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
struct identificador
{
  tipo_1 comp_1;
  tipo_2 comp_2;
  ...
  tipo_n comp_n;
};
\end{lstlisting}
\begin{description}
\item[{identificador}] Nombre de la estructura
\item[{\texttt{tipo\_n}}] Tipo de datos del componente \texttt{comp\_n}.
\item[{\texttt{comp\_n}}] Componente n-ésimo de la estructura.
\end{description}
\end{frame}

\begin{frame}[label={sec:org5439d23},fragile]{Estructuras con \texttt{typedef struct}}
 Permiten usar estructuras (u otros tipos) sin necesidad de usar la
palabra clave \texttt{struct}.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct 
{
  tipo_1 comp_1;
  tipo_2 comp_2;
  ...
  tipo_n comp_n;
} identificador;
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org2d1ffcf},fragile]{Ejemplo con \texttt{struct}}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
struct contacto
{
  char nombre[30];
  int telefono;
  int edad;
};

int main()
{
  struct contacto person1;

  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgecf3331},fragile]{Ejemplo con \texttt{typedef struct}}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct 
{
  char nombre[30];
  int telefono;
  int edad;
} contacto;

int main()
{
  contacto person1;
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgf79deb7},fragile]{Inicialización de valores en estructuras}
 Si no se especifica el identificador de cada componente la asignación se realiza en orden

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct {
  char nombre[50];
  char apellidos[50];
  int matricula;
} ficha;

int main ()
{
  ficha alumno1 = {"Yo", "Soy Aquel", 1234};
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:org42d3447},fragile]{Inicialización de valores en estructuras}
 Con el identificador de cada componente se puede asignar en cualquier orden

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct {
  char nombre[50];
  char apellidos[50];
  int matricula;
} ficha;

int main ()
{
  ficha alumno1 = {.apellidos = "Soy Aquel",
		   .matricula = 1234, 
		   .nombre = "Yo"};
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org6726788},fragile]{Asignación de valores en estructuras}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct {
  int day;
  int month;
  int year;
} date;

int main () {
  date d1, d2, d3;
  // Asignacion por componentes
  d1.day = 31;
  d1.month = 12;
  d1.year = 1999;
  // Asignacion con el operador cast
  d2 = (date) {1, 1, 2000};
  // Asignacion por copia
  d3 = d1;
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org42d1e50},fragile]{Asignación de cadenas en estructuras}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

typedef struct {
  char nombre[50];
  char apellidos[50];
  int matricula;
} ficha;

int main ()
{
  ficha alumno1, alumno2, alumno3;
  // Para asignar cadenas usamos strcpy
  strcpy(alumno1.nombre, "Yo");
  strcpy(alumno1.apellidos, "Soy Aquel");
  alumno1.matricula = 1234;
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org07e208b},fragile]{Acceso a componentes de una estructura}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

typedef struct {
  char nombre[50];
  char apellidos[50];
  int matricula;
} ficha;

int main () {
  ficha alumno;
  printf("Nombre:");
  scanf("%s", alumno.nombre);
  printf("Apellidos:");
  scanf("%s", alumno.apellidos);
  printf("Numero de matricula:");
  scanf("%d", &alumno.matricula);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org8d83103},fragile]{Estructuras dentro de estructuras}
 Una estructura puede contener otras estructuras.

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
typedef struct
{
  int d, m, a;
} fecha;

typedef struct
{
  char nombre[50];
  char apellidos[50];
  int matricula;
  fecha fNacimiento;
} ficha;
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:orgcc95606},fragile]{Estructuras dentro de estructuras}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
ficha alumno1, alumno2;

alumno1.fNacimiento.d = 31;
alumno1.fNacimiento.m = 12;
alumno1.fNacimiento.a = 1999;

alumno2.fNacimiento = (fecha){1, 1, 2000};
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgd788932},fragile,plain]{Vector de estructuras}
 A partir de una estructura previamente definida se pueden generar vectores basados en esa estructura.
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

typedef struct
{
  int day;
  int month;
  int year;
} date;

int main() {
  date fechas[3] = {// Vector de 3 fechas
    {1, 1, 1999},
    {31, 12, 2000},
    {15, 5, 1980}
  };
  return 0;
}
\end{lstlisting}
\end{frame}


\begin{frame}[label={sec:org835f34a},fragile,plain]{Vector de estructuras}
 La asignación de valores sigue las mismas reglas que para vectores de tipos simples (mediante \texttt{[]}).
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

typedef struct
{
  int day;
  int month;
  int year;
} date;

int main() {
  date fechas[3]; // Vector de 3 fechas
  fechas[1].day = 1;
  fechas[2] = (date) {31, 12, 1999};
  fechas[3] = fechas[2];
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgc55411f},fragile,plain]{Funciones y estructuras}
 Una función acepta estructuras (\alert{paso por valor}).

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <math.h>
//Definicion de estructura
typedef struct {
  float real, imaginaria;
} complejo;
//Funcion que acepta una estructura
float modulo(complejo c);

int main(){
  complejo comp={1, 3};
  printf("El modulo es: %f\n", modulo(comp));
  return 0;
}
//Implementacion de la funcion
float modulo(complejo c){
  return sqrt(c.real * c.real + c.imaginaria * c.imaginaria);
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:orgffef8e6},fragile,plain]{Funciones y estructuras}
 Una función puede devolver una estructura

\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>

typedef struct {
  float real, imaginaria;
} complejo;
//Funcion que devuelve estructura
complejo conjugado(complejo c);

int main(){
  complejo comp1 = {1, 3}, comp2;
  comp2 = conjugado(comp1);
  printf("%f", comp2.imaginaria);
  return 0;
}

complejo conjugado(complejo c){
  return (complejo) {c.real, -c.imaginaria}; 
}
\end{lstlisting}
\end{frame}

\section{Enumeraciones}
\label{sec:orge7fbda9}
\begin{frame}[label={sec:org2f9c081},fragile]{Enumeraciones en C}
 \begin{block}{Definición}
Con \texttt{enum} se pueden definir tipos de datos enteros que tengan un rango limitado de valores, y darle un nombre significativo a cada uno de los
posibles valores.
\end{block}
\begin{block}{Código}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
enum nombre_enum {lista_de_valores};
\end{lstlisting}
\end{block}
\begin{block}{Ejemplo}
\lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
enum dia{ //valores enteros: 0 al 6
  lunes, martes, miercoles, jueves, viernes, sabado, domingo
};

\end{lstlisting}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgbb8435f},fragile]{Ejemplo (1)}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
enum dia{ //valores enteros: 0 al 6
  lunes, martes, miercoles, jueves, viernes, sabado, domingo
};

int main()
{
  enum dia hoy, manana;
  hoy = lunes;
  manana = hoy + 1;
  printf("%d\n", hoy);
  printf("%d\n", manana);
  return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[label={sec:org913c8fd},fragile]{Ejemplo (2)}
 \lstset{language=C,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
#include <stdio.h>
enum dia{ //valores enteros: 1 en adelante
  lunes = 1, martes, miercoles, jueves, viernes, sabado, domingo
};

int main()
{
  enum dia hoy, manana;
  hoy = lunes;
  manana = hoy + 1;
  printf("%d\n", hoy);
  printf("%d\n", manana);
  return 0;
}
\end{lstlisting}
\end{frame}
\end{document}